#include <iostream>

using namespace std;

#include <ctime>
#include <Eigen/Core>
#include <Eigen/Dense>

#define MATRIX_SIZE 50

using namespace Eigen;

int main()
{
	// Create a Eigen::Matrix
	Matrix<float, 2, 3> matrix_23;
	
	Vector3d v_3d;
	
	Matrix<float, 3, 1> vd_3d;
	
	Matrix3d matrix_33 = Matrix3d::Zero();
	
	// Matrix with dynamic size
	Eigen::Matrix<double, Dynamic, Dynamic> matrix_dynamic;
	
	Eigen::MatrixXd matrix_x;
	
	matrix_23<<1,2,3,4,5,6;
	
	cout<<"Matrix 2x3 from 1 to 6: \n"<<matrix_23<<endl;
	
	cout<<"Print matrix 2x3: "<<endl;
	for(int i =0 ; i < 2 ; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			cout<<matrix_23(i, j)<<"\t";
		}
		cout<<endl;
	}
	
	Matrix<double, 2, 1> result = matrix_23.cast<double>() * v_3d;
    cout << "[1,2,3;4,5,6]*[3,2,1]=" << result.transpose() << endl;

    Matrix<float, 2, 1> result2 = matrix_23 * vd_3d;
    cout << "[1,2,3;4,5,6]*[4,5,6]: " << result2.transpose() << endl;
	
	matrix_33 = Eigen::Matrix3d::Random();
	cout<<"random matrix : \n"<<matrix_33<<endl;
	cout<<"transpose : \n"<<matrix_33.transpose()<<endl;
	cout<<"sum: "<<matrix_33.sum()<<endl;
	cout<<"trace: "<<matrix_33.trace()<<endl;
	cout<<"times 10: \n"<<10*matrix_33<<endl;
	cout<<"inverse : \n"<<matrix_33.inverse()<<endl;
	cout<<"det: "<<matrix_33.determinant()<<endl;
	
	// Eigenvalues
    // Real symmetric matrix can guarantee successful diagonalization
	SelfAdjointEigenSolver<Matrix3d> eigen_solver(matrix_33.transpose() * matrix_33);
    cout << "Eigen values = \n" << eigen_solver.eigenvalues() << endl;
    cout << "Eigen vectors = \n" << eigen_solver.eigenvectors() << endl;
	
	// Solving equations
    // We solve the equation matrix_NN * x = v_Nd
    // The size of N is defined in the previous macro, which is generated by a random number
    // Direct inversion is the most direct, but the amount of inverse operations is large.
	
	Matrix<double, MATRIX_SIZE, MATRIX_SIZE> matrix_NN
      = MatrixXd::Random(MATRIX_SIZE, MATRIX_SIZE);
    matrix_NN = matrix_NN * matrix_NN.transpose();  
    Matrix<double, MATRIX_SIZE, 1> v_Nd = MatrixXd::Random(MATRIX_SIZE, 1);
	
	return 0;
}
